// Generated by dts-bundle v0.7.3





declare global {
    /**
        * The config for the mod, as set by the user, with default values filled in.
        */
    const config: ModConfigValue;

    /**
        * The global console object. It works similarly to the one provided by DOM or Node.
        */
    // @ts-ignore[2649]: overriding global console
    const console: ConsoleAPI;

    /**
        * The D2RMM API. Use this to interact with the game's files.
        */
    const D2RMM: ModAPI;
}

export type ILogLevel = 'error' | 'warn' | 'log' | 'debug';

/**
    * Because we're passing console arguments across multiple bridges
    * between Electron main, Electron renderer, and QuickJS, we need
    * to restrict the types of the arguments to a subset that can be
    * serialized and deserialized across these boundaries.
    */
type ConsoleArg =
    | undefined
    | null
    | Error
    | boolean
    | number
    | string
    | ConsoleArg[]
    | { [key: string]: ConsoleArg };

/**
    * A console interface similar to that provided by the DOM or Node.
    * It will print to D2RMM's logs tab.
    * @see https://developer.mozilla.org/en-US/docs/Web/API/Console
    *
    * @example
    * ```
    * console.log('Hello, world!');
    * ```
    */
export interface ConsoleAPI {
    /**
        * Outputs a message to the console with the log level 'debug'.
        * @param args - The data to log.
        */
    debug: (...args: ConsoleArg[]) => void;
    /**
        * Outputs a message to the console with the log level 'info'.
        * @param args - The data to log.
        */
    log: (...args: ConsoleArg[]) => void;
    /**
        * Outputs a message to the console with the log level 'warn'.
        * @param args - The data to log.
        */
    warn: (...args: ConsoleArg[]) => void;
    /**
        * Outputs a message to the console with the log level 'error'.
        * @param args - The data to log.
        */
    error: (...args: ConsoleArg[]) => void;
}







/**
    * This is the interface of the global "D2RMM" variable provided to mods at runtime.
    *
    * @example
    * ```
    * const version = D2RMM.getVersion();
    * ```
    */
export interface ModAPI {
    /**
        * Returns the configuration of the mod as a JSON string.
        * @note This is an internal API. You should reference the JSON parsed version of this value using the global `config` object instead.
        * @example
        * ```
        * const config = D2RMM.getConfigJSON();
        * console.log('isFooEnabled = ' + JSON.parse(config).isFooEnabled);
        * ```
        * @returns The configuration of the mod.
        * @internal
        */
    getConfigJSON: () => string;

    /**
        * Returns the version of D2RMM composed of the major and minor versions as a float.
        * @note You can use this API to check if the installed version of D2RMM is compatible
        *       with the APIs that your mod is using.
        * @example
        * ```
        * const version = D2RMM.getVersion(); // 1.5
        * ```
        * @returns The version including the major and the minor number.
        */
    getVersion: () => number;

    /**
        * Returns the full version of D2RMM composed of the major, minor, and patch versions as an array of integers.
        * @note Mods should not need to rely on the patch version.
        * @example
        * ```
        * const [major, minor, patch] = D2RMM.getFullVersion();
        * ```
        * @returns The version including the major, minor, and patch numbers.
        */
    getFullVersion: () => [number, number, number];

    /**
        * Returns the list of mods being installed.
        * @example
        * ```
        * const modList = D2RMM.getModList();
        * modList.forEach(mod => {
        *   console.log(
        *     `mod ${mod.name} (${mod.id})`,
        *     `v${mod.version}`,
        *     `is ${mod.installed ? 'already installed' : 'not yet installed'}`,
        *     `with config ${JSON.stringify(mod.config)}`,
        *   );
        * });
        * ```
        * @returns The list of installed mods.
        */
    getModList: () => {
        id: Mod['id'];
        name: ModConfig['name'];
        version: ModConfig['version'];
        installed: boolean;
        config: ModConfigValue;
    }[];

    /**
        * Reads a JSON D2R file.
        * @note D2R's JSON files don't follow the standard JSON spec. This method will
        *       ignore any comments, whitespace, and various invalid properties (for example,
        *       duplicate keys), that D2R might use.
        * @note The file is either read from D2R game files as specified in D2RMM's config,
        *       or is the result of previously installed mods already operating on this file.
        * @example
        * ```
        * const profileHD = D2RMM.readJson('global\\ui\\layouts\\_profilehd.json');
        * profileHD.FontColorRed.r; // 252
        * ```
        * @param filePath - The path of the file to read, relative to the data directory.
        * @returns The parsed JSON data.
        */
    readJson: (filePath: string) => JSONData;

    /**
        * Writes a JSON D2R file.
        * @example
        * ```
        * // change red colored text to bright green!
        * const profileHD = D2RMM.readJson('global\\ui\\layouts\\_profilehd.json');
        * profileHD.FontColorRed = {r: 0, b: 0, g: 255, a: 255};
        * D2RMM.writeJson('global\\ui\\layouts\\_profilehd.json', profileHD);
        * ```
        * @param filePath - The path of the file to write, relative to the data directory.
        * @param data - The JSON data to write.
        */
    writeJson: (filePath: string, data: JSONData) => void;

    /**
        * Reads a TSV (tab separated values in a .txt) D2R file. This is a classic data format used by D2.
        * @note The last column in the file will probably have a `\r` at the end of its name.
        * @note The file is either read from D2R game files as specified in D2RMM's config,
        *       or is the result of previously installed mods already operating on this file.
        * @example
        * ```
        * const treasureclassex = D2RMM.readTsv('global\\excel\\treasureclassex.txt');
        * console.log('There are ' + treasureclassex.rows.length + ' treasure classes!');
        * console.log('Each treasure class has ' + treasureclassex.headers.length + ' properties!');
        * ```
        * @param filePath - The path of the file to read, relative to the data directory.
        * @returns The parsed TSV data.
        */
    readTsv: (filePath: string) => TSVData;

    /**
        * Writes a TSV (tab separated values in a .txt) D2R file. This is a classic data format used by D2.
        * @example
        * ```
        * const treasureclassex = D2RMM.readTsv('global\\excel\\treasureclassex.txt');
        * treasureclassex.rows.forEach(row => {
        *   // D2R TSV files sometimes have blank rows
        *   if (row['Treasure Class'] !== '') {
        *     row.NoDrop = 1;
        *   }
        * });
        * D2RMM.writeTsv('global\\excel\\treasureclassex.txt', treasureclassex);
        * ```
        * @param filePath - The path of the file to write, relative to the data directory.
        * @param data - The TSV data to write.
        */
    writeTsv: (filePath: string, data: TSVData) => void;

    /**
        * Reads a plain text D2R file.
        * @note The file is either read from D2R game files as specified in D2RMM's config,
        *       or is the result of previously installed mods already operating on this file.
        * @example
        * ```
        * const nextStringIDRaw = D2RMM.readJson('local\\next_string_id.txt');
        * let nextStringID = nextStringIDRaw.match(/[0-9]+/)[0]; // next valid string id
        * ```
        * @param filePath - The path of the file to read, relative to the data directory.
        * @returns The raw text data.
        */
    readTxt: (filePath: string) => string;

    /**
        * Writes a plain text D2R file.
        * @example
        * ```
        * const nextStringIDRaw = D2RMM.readTxt('local\\next_string_id.txt');
        * let nextStringID = nextStringIDRaw.match(/[0-9]+/)[0]; // next valid string id
        * nextStringID ++;
        * nextStringIDRaw.replace(/[0-9]+/, nextStringID);
        * D2RMM.writeTxt('local\\next_string_id.txt', nextStringIDRaw);
        * ```
        * @param filePath - The path of the file to write, relative to the data directory.
        * @param data - The raw text data to write.
        */
    writeTxt: (filePath: string, data: string) => void;

    /**
        * Reads a save file from the saves directory as binary. The result is an array of bytes.
        * @example
        * ```
        * const stashData = D2RMM.readSaveFile('SharedStashSoftCoreV2.d2i');
        * console.log('Save file size: ' + stashData.length);
        * ```
        * @param filePath - The path of the save file to read, relative to the saves directory.
        * @returns The binary data of the save file.
        */
    readSaveFile: (filePath: string) => number[] | null;

    /**
        * Writes a save file to the saves directory as binary.
        * @note It's highly recommended to write a backup of any save file you are modifying
        *       because save files can be corrupted if written incorrectly.
        * @example
        * ```
        * const stashData = D2RMM.readSaveFile('SharedStashSoftCoreV2.d2i');
        * D2RMM.writeSaveFile('SharedStashSoftCoreV2.d2i', stashData.concat(EXTRA_STASH_TAB));
        * ```
        * @param filePath - The path of the save file to write, relative to the saves directory.
        * @param data - The binary data of the save file to write as an array of bytes.
        */
    writeSaveFile: (filePath: string, data: number[]) => void;

    /**
        * Copies a file or directory from the mod directory to the data directory. This
        * is primarily used for including non-mergeable assets like sprites in your mod.
        * @note While you can use this API to provide whole new versions of TSV/JSON game
        *       files to the game, this is an anti-pattern and will dramatically reduce your
        *       mod's compatibility with other mods. Don't do it. Use the `read*` and `write*`
        *       APIs instead.
        * @param src - The path of the file or directory to copy, relative to the mod directory.
        * @param dst - The path of the file or directory to copy to, relative to the data directory.
        * @param overwrite - Whether to overwrite any conflicts.
        * @example
        * ```
        * // copy new sprites to the output directory
        * D2RMM.copyFile(
        *   'hd', // <mod folder>\hd
        *   'hd', // <diablo 2 folder>\mods\D2RMM\D2RMM.mpq\data\hd
        *   true // overwrite any conflicts
        * );
        * ```
        */
    copyFile: (src: string, dst: string, overwrite?: boolean) => void;

    /**
        * Produces the next valid string ID to use as an identifier in D2R's data files.
        * The ID is read from `next_string_id.txt`, and then incremented within that file.
        * @returns The next valid string ID.
        */
    getNextStringID: () => number;

    /**
        * Shows an error message to the user.
        * @deprecated Use `console.error()` or `throw new Error()` instead.
        * @param message - The message to show.
        * @example
        * ```
        * D2RMM.error('Something went wrong!');
        * D2RMM.error(new Error('Something went wrong!'));
        * ```
        */
    error: (message: string | Error) => void;
}

/**
    * @internal
    */
export type AsyncModAPI = {
    [K in keyof ModAPI]: (
        ...args: Parameters<ModAPI[K]>
    ) => Promise<ReturnType<ModAPI[K]>>;
};

/**
    * Represents the valid value of any single configuration field.
    */
export type ModConfigSingleValue =
    | string
    | number
    | boolean
    | string[]
    | number[];

/**
    * This is the structure of the mod config as it is passed to the
    * mod's implementation.
    */
export type ModConfigValue = Readonly<{
    [key: string]: ModConfigSingleValue;
}>;







export type IInstallModsOptions = {
    dataPath: string;
    gamePath: string;
    isDirectMode: boolean;
    isDryRun: boolean;
    isPreExtractedData: boolean;
    mergedPath: string;
    outputModName: string;
    preExtractedDataPath: string;
};

export type Mod = {
    id: string;
    info: ModConfig;
    config: ModConfigValue;
};

export type CopiedFile = {
    fromPath: string;
    toPath: string;
};

export type IBridgeAPI = {
    closeStorage: () => Promise<boolean>;
    copyFile: (
        fromPath: string,
        toPath: string,
        overwrite?: boolean,
        outCopiedFiles?: CopiedFile[],
    ) => Promise<number>;
    createDirectory: (filePath: string) => Promise<boolean>;
    deleteFile: (filePath: string, relative: Relative) => Promise<number>;
    execute: (
        executablePath: string,
        args?: string[],
        sync?: boolean,
    ) => Promise<number>;
    isGameFile: (filePath: string) => Promise<boolean>;
    extractFile: (filePath: string, targetPath: string) => Promise<boolean>;
    getAppPath: () => Promise<string>;
    getGamePath: () => Promise<string | null>;
    getVersion: () => Promise<[number, number, number]>;
    installMods: (
        modsToInstall: Mod[],
        options: IInstallModsOptions,
    ) => Promise<string[]>;
    openStorage: (gamePath: string) => Promise<boolean>;
    readDirectory: (
        filePath: string,
    ) => Promise<{ name: string; isDirectory: boolean }[]>;
    readFile: (filePath: string, relative: Relative) => Promise<string | null>;
    readBinaryFile: (
        filePath: string,
        relative: Relative,
    ) => Promise<number[] | null>;
    readJson: (filePath: string) => Promise<JSONData>;
    readModCode: (id: string) => Promise<[string, string]>;
    readModConfig: (id: string) => Promise<JSONData>;
    readModDirectory: () => Promise<string[]>;
    readModInfo: (id: string) => Promise<ModConfig>;
    readTsv: (filePath: string) => Promise<TSVData>;
    readTxt: (filePath: string) => Promise<string>;
    writeFile: (
        inputPath: string,
        relative: Relative,
        data: string,
    ) => Promise<number>;
    writeBinaryFile: (
        inputPath: string,
        relative: Relative,
        data: number[],
    ) => Promise<number>;
    writeJson: (filePath: string, data: JSONData) => Promise<number>;
    writeModConfig: (id: string, value: ModConfigValue) => Promise<number>;
    writeTsv: (filePath: string, data: TSVData) => Promise<number>;
    writeTxt: (filePath: string, data: string) => Promise<number>;
};

/**
    * The parsed data of a JSON file.
    */
export type JSONData =
    | boolean
    | number
    | string
    | JSONData[]
    | { [key: string]: JSONData };




/**
    * The structure of the "mod.json" file that D2RMM mods should provide.
    */
export interface ModConfig {
    /**
        * The type of the mod.
        * @ignore - This property is generated by D2RMM itself.
        */
    type: 'd2rmm' | 'data';

    /**
        * The name of the mod.
        */
    name: string;

    /**
        * A short description of the mod.
        */
    description?: string;

    /**
        * The author of the mod.
        */
    author?: string;

    /**
        * The website of the mod. Ideally, this should link to the Nexus Mods page for the mod.
        */
    website?: string;

    /**
        * The version of the mod.
        */
    version?: string;

    /**
        * The configuration for the mod. This allows the mod to set up a custom configuration UI
        * that the user can interact with to customize the behavior of the mod.
        *  @see {@link ModConfigSection}
        *  @see {@link ModConfigFieldCheckbox}
        *  @see {@link ModConfigFieldColor}
        *  @see {@link ModConfigFieldNumber}
        *  @see {@link ModConfigFieldSelect}
        *  @see {@link ModConfigFieldText}
        */
    config?: readonly ModConfigFieldOrSection[];
}

/**
    * A single configuration field or section.
    * @ignore
    */
export type ModConfigFieldOrSection = ModConfigSection | ModConfigField;

/**
    * The base structure of any element in the configuration UI.
    * @ignore
    */
export interface ModConfigBase {
    /**
        * The type of the configuration element.
        */
    type: string;

    /**
        * The unique identifier of the configuration element.
        */
    id: string;
}

/**
    * A section in the configuration UI that can contain other fields or sections.
    */
export interface ModConfigSection extends ModConfigBase {
    /**
        * The type of the configuration element.
        */
    type: 'section';

    /**
        * The name of the section.
        */
    name: string;

    /**
        * Whether the section should be expanded by default.
        */
    defaultExpanded?: boolean;

    /**
        * The fields or sections that are contained within this section.
        */
    children?: readonly ModConfigFieldOrSection[];
}

/**
    * The base structure of any configuration field in the configuration UI.
    * @ignore
    */
export interface ModConfigFieldBase extends ModConfigBase {
    /**
        * The description for the field that appears in a help tooltip.
        */
    description: string;

    /**
        * The name of the field.
        */
    name: string;

    /**
        * Determines if the field is visible or not.
        */
    visible?: Binding<boolean>;
}

/**
    * Represents a boolean (true/false) configuration field that will be represented
    * as a checkbox or toggle element in the configuration UI.
    */
export interface ModConfigFieldCheckbox extends ModConfigFieldBase {
    /**
        * The type of the configuration element.
        */
    type: 'checkbox';

    /**
        * The default value of the checkbox field.
        */
    defaultValue: boolean;
}

/**
    * Represents a number configuration field that will be represented as a number
    * input in the configuration UI.
    */
export interface ModConfigFieldNumber extends ModConfigFieldBase {
    /**
        * The type of the configuration element.
        */
    type: 'number';

    /**
        * The default value of the number field.
        */
    defaultValue: number;

    /**
        * The minimum value that the user can input.
        */
    minValue?: number;

    /**
        * The maximum value that the user can input.
        */
    maxValue?: number;
}

/**
    * Represents a text configuration field that will be represented as a text input
    * in the configuration UI.
    */
export interface ModConfigFieldText extends ModConfigFieldBase {
    /**
        * The type of the configuration element.
        */
    type: 'text';

    /**
        * The default value of the text field.
        */
    defaultValue: string;
}

/**
    * Represents a select configuration field that will be represented as a dropdown
    * select element in the configuration UI.
    */
export interface ModConfigFieldSelect extends ModConfigFieldBase {
    /**
        * The type of the configuration element.
        */
    type: 'select';

    /**
        * The default value of the select field.
        */
    defaultValue: ModConfigSingleValue;

    /**
        * The options that the user can select from.
        */
    options: {
        /**
            * The description of the option that appears underneath the label in the dropdown.
            */
        description?: string;

        /**
            * The label of the option that will be displayed in the dropdown.
            */
        label: string;

        /**
            * The value of the option that will be used when the user selects it.
            */
        value: ModConfigSingleValue;
    }[];
}

/**
    * Represents a color configuration field that will be represented as a color picker
    * element in the configuration UI.
    */
export interface ModConfigFieldColor extends ModConfigFieldBase {
    /**
        * The type of the configuration element.
        */
    type: 'color';

    /**
        * The default value of the color in RGBA format (`[0, 255]`, `[0, 255]`, `[0, 255]`, `[0.0, 1.0]`).
        */
    defaultValue: [number, number, number, number];

    /**
        * Whether the alpha channel should be hidden in the color picker.
        */
    isAlphaHidden?: boolean;
}

/**
    * Represents a single configuration field.
    * @ignore
    */
export type ModConfigField =
    | ModConfigFieldCheckbox
    | ModConfigFieldNumber
    | ModConfigFieldText
    | ModConfigFieldSelect
    | ModConfigFieldColor;

/**
    * The name of a column in a TSV file.
    */
export type TSVDataHeader = string;

/**
    * A single row in a TSV file.
    */
export type TSVDataRow = {
    [header: TSVDataHeader]: string;
};

/**
    * The parsed data of a TSV file.
    */
export type TSVData = {
    /**
        * List of headers in the TSV file.
        */
    headers: TSVDataHeader[];
    /**
        * List of rows in the TSV file.
        */
    rows: TSVDataRow[];
};

export type Relative =
    /**
        * Absolute path.
        * @deprecated
        */
    | 'None'
    /**
        * Path is relative to D2RMM's directory.
        */
    | 'App'
    /**
        * Path is relative to the game's save file directory.
        * @example %UserProfile%\Saved Games\Diablo II Resurrected\mods\D2RMM\
        */
    | 'Saves'
    /**
        * Path is relative to the directory that the MPQ mod is being generated in.
        * @example C:\Games\Diablo II Resurrected\mods\D2RMM\D2RMM.mpq\data\
        * @example C:\Games\Diablo II Resurrected\data\
        */
    | 'Output';



/**
    * A literal JSON value.
    * @example
    * ```
    * {
    *   // ...
    *   "visible": true,
    * },
    * ```
    */
export type BindingLiteralValue<T> = T;

/**
    * Returns the value of a configuration field.
    * @example
    * ```
    * {
    *   "id": "MyConfigField",
    *   "type": "checkbox",
    * },
    * {
    *   // ...
    *   "visible": ["value", "MyConfigField"],
    * },
    */
export type BindingConfigValue<_T extends ModConfigSingleValue> = [
    operator: 'value',
    id: string,
];

/**
    * If the first parameter (`boolean`) is true, returns the second parameter (`T`), otherwise returns the third parameter (`T`).
    * @remarks
    * The type of the second and third parameters must be the same.
    * @example
    * ```
    * {
    *   "id": "MyConfigField",
    *   "type": "checkbox",
    * },
    * {
    *   // ...
    *   "visible": ["if", ["value", "MyConfigField"], true, false],
    * },
    * ```
    */
export type BindingConditional<T> = [
    operator: 'if',
    condition: Binding<boolean>,
    thenBinding: Binding<T>,
    elseBinding: Binding<T>,
];

/**
    * Checks if the parameter (`boolean`) is false.
    * @example
    * ```
    * {
    *   "id": "MyConfigField",
    *   "type": "checkbox",
    * },
    * {
    *   // ...
    *   "visible": ["not", ["value", "MyConfigField"]],
    * },
    * ```
    */
export type BindingNot = [operator: 'not', binding: Binding<boolean>];

/**
    * Checks if both the first parameters (`boolean`) and the second parameter (`boolean`) are both true.
    * @example
    * ```
    * {
    *   "id": "MyConfigField1",
    *   "type": "checkbox",
    * },
    * {
    *   "id": "MyConfigField2",
    *   "type": "checkbox",
    * },
    * {
    *   // ...
    *   "visible": ["and", ["value", "MyConfigField1"], ["value", "MyConfigField2"]],
    * },
    * ```
    */
export type BindingAnd = [
    operator: 'and',
    binding1: Binding<boolean>,
    binding2: Binding<boolean>,
];

/**
    * Checks if either the first parameters (`boolean`) or the second parameter (`boolean`) is true.
    * @example
    * ```
    * {
    *   "id": "MyConfigField1",
    *   "type": "checkbox",
    * },
    * {
    *   "id": "MyConfigField2",
    *   "type": "checkbox",
    * },
    * {
    *   // ...
    *   "visible": ["or", ["value", "MyConfigField1"], ["value", "MyConfigField2"]],
    * },
    * ```
    */
export type BindingOr = [
    operator: 'or',
    binding1: Binding<boolean>,
    binding2: Binding<boolean>,
];

/**
    * Checks if the first parameter (`T`) is equal to the second parameter (`T`).
    * @example
    * ```
    * {
    *   "id": "MyConfigField",
    *   "type": "number",
    * },
    * {
    *   // ...
    *   "visible": ["eq", ["value", "MyConfigField"], 123],
    * },
    * ```
    */
export type BindingEquals<T> = [
    operator: 'eq',
    binding1: Binding<T>,
    binding2: Binding<T>,
];

/**
    * Checks if the first parameter (`T`) is not equal to the second parameter (`T`).
    * @example
    * ```
    * {
    *   "id": "MyConfigField",
    *   "type": "number",
    * },
    * {
    *   // ...
    *   "visible": ["neq", ["value", "MyConfigField"], 123],
    * },
    * ```
    */
export type BindingNotEquals<T> = [
    operator: 'neq',
    binding1: Binding<T>,
    binding2: Binding<T>,
];

/**
    * Checks if the first parameter (`number`) is less than the second parameter (`number`).
    * @example
    * ```
    * {
    *   "id": "MyConfigField",
    *   "type": "number",
    * },
    * {
    *   // ...
    *   "visible": ["lt", ["value", "MyConfigField"], 123],
    * },
    * ```
    */
export type BindingLessThan = [
    operator: 'lt',
    binding1: Binding<number>,
    binding2: Binding<number>,
];

/**
    * Checks if the first parameter (`number`) is less than or equal to the second parameter (`number`).
    * @example
    * ```
    * {
    *   "id": "MyConfigField",
    *   "type": "number",
    * },
    * {
    *   // ...
    *   "visible": ["lte", ["value", "MyConfigField"], 123],
    * },
    * ```
    */
export type BindingLessThanOrEqual = [
    operator: 'lte',
    binding1: Binding<number>,
    binding2: Binding<number>,
];

/**
    * Checks if the first parameter (`number`) is greater than the second parameter (`number`).
    * @example
    * ```
    * {
    *   "id": "MyConfigField",
    *   "type": "number",
    * },
    * {
    *   // ...
    *   "visible": ["gt", ["value", "MyConfigField"], 123],
    * },
    * ```
    */
export type BindingGreaterThan = [
    operator: 'gt',
    binding1: Binding<number>,
    binding2: Binding<number>,
];

/**
    * CHecks if the first parameter (`number`) is greater than or equal to the second parameter (`number`).
    * @example
    * ```
    * {
    *   "id": "MyConfigField",
    *   "type": "number",
    * },
    * {
    *   // ...
    *   "visible": ["gte", ["value", "MyConfigField"], 123],
    * },
    * ```
    */
export type BindingGreaterThanOrEqual = [
    operator: 'gte',
    binding1: Binding<number>,
    binding2: Binding<number>,
];

/**
    * Checks if the first parameter (`string` or `number`) is a part of the second parameter (`string[]` or `number[]`).
    * @example
    * ```
    * {
    *   "id": "MyConfigField",
    *   "type": "text",
    * },
    * {
    *   // ...
    *   "visible": ["in", "foo", ["value", "MyConfigField"]],
    * },
    * ```
    */
export type BindingIncludes<T> = [
    operator: 'in',
    binding1: Binding<T>,
    binding2: T extends string
        ? Binding<string[]>
        : T extends number
            ? Binding<number[]>
            : never,
];

/**
    * A binding that can be dynamically evaluated to a `string` value.
    */
type StringBinding =
    | BindingLiteralValue<string>
    | BindingConfigValue<string>
    | BindingConditional<boolean>;

/**
    * A binding that can be dynamically evaluated to a `number` value.
    */
type NumberBinding =
    | BindingLiteralValue<number>
    | BindingConfigValue<number>
    | BindingConditional<boolean>;

/**
    * A binding that can be dynamically evaluated to a `boolean` value.
    */
type BooleanBinding =
    | BindingLiteralValue<boolean>
    | BindingConfigValue<boolean>
    | BindingConditional<boolean>
    | BindingNot
    | BindingAnd
    | BindingOr
    | BindingEquals<string>
    | BindingEquals<boolean>
    | BindingEquals<number>
    | BindingNotEquals<string>
    | BindingNotEquals<boolean>
    | BindingNotEquals<number>
    | BindingLessThan
    | BindingLessThanOrEqual
    | BindingGreaterThan
    | BindingGreaterThanOrEqual
    | BindingIncludes<string>
    | BindingIncludes<number>;

/**
    * A binding that can be dynamically evaluated to a `string[]` value.
    */
type StringArrayBinding =
    | BindingLiteralValue<string[]>
    | BindingConfigValue<string[]>
    | BindingConditional<boolean>;

/**
    * A binding that can be dynamically evaluated to a `number[]` value.
    */
type NumberArrayBinding =
    | BindingLiteralValue<number[]>
    | BindingConfigValue<number[]>
    | BindingConditional<boolean>;

/**
    * A binding that can be dynamically evaluated to a value.
    * @example
    * ```
    * {
    *   "id": "MyConfigField",
    *   "type": "checkbox",
    * },
    * {
    *   // ...
    *   "visible": ["value", "MyConfigField"],
    * },
    * ```
    */
export type Binding<T> =
    // check type of T and return appropriate Binding type
    T extends string
        ? StringBinding
        : T extends number
            ? NumberBinding
            : T extends boolean
                ? BooleanBinding
                : T extends string[]
                    ? StringArrayBinding
                    : T extends number[]
                        ? NumberArrayBinding
                        : BindingLiteralValue<T>;

